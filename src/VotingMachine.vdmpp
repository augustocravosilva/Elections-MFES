class VotingMachine

types
	public Status = <Off> | <Ready> | <OnVoting> | <End>;
	public MemCard = map Election`Candidate to nat;

instance variables
	public status : Status := <Off>; 
	public vcard : ElectoralOfficial`Card := mk_token(1);
	public vcardSet : bool := false;
	public choice : Election`Candidate := "";
	public votes: MemCard := { |-> };

	------- TODO: o cartao de memoria nao muda
	-- when machine is working it has a vcard set
	inv (status = <Ready> or status = <OnVoting>) => vcardSet;
	-- the choice must be valid
	inv choice in set(dom votes union {""});
	-- if choice not empty state = <onVoting>
	inv choice <> "" => status = <OnVoting>;
	
operations
 	-- Election class constructor
	-- returns created object 
 	public VotingMachine: () ==> VotingMachine
 		VotingMachine() == (
 			return self;
 			);
 	
 	-- Initialize memory and validation cards
 	-- R1: before operation, status must be <Off>
 	-- card must not been entered yet
 	public setCards: ElectoralOfficial`Card ==> ()
 		setCards(vcard1) == (
 			vcard := vcard1;
 			vcardSet := true;
 	)
 	pre status = <Off> and not vcardSet
 	post status = <Off> and vcardSet;
 	
 	-- Turn on the machine
 	public turnOn: ElectoralOfficial`Card ==> ()
 		turnOn(vcard1) == (
 			status := <Ready>
 	)
 	pre vcard1 = vcard
 		and status = <Off>
 	post status = <Ready>;
 	
 	-- Candidates initialization
	public setCandidates: set of Election`Candidate ==> ()
		setCandidates(candidates) == (
			for all candidate in set candidates do
			votes := votes munion {candidate |-> 0}
			)
	pre
		-- machine is still off
		status = <Off>
	post
		-- all candidates have 0 votes
		forall vote in set rng votes & vote = 0;
 	
 	-- Machine ready to receive vote
 	-- R1: before operation, status must be <Ready> 
	public validateCard: ElectoralOfficial`Card ==> ()
		validateCard(vcard1) == atomic (
			status := <OnVoting>;
			choice := ""
			)
	pre status = <Ready> and
		vcard1 = vcard
	post status = <OnVoting>;
		
	-- Select candidate
	-- R1: machine is on <OnVoting> status
	-- R2: argument "cand" is a valid candidate (is on memory card)
	public chooseCandidate: Election`Candidate ==> ()
		chooseCandidate(cand) ==
			choice := cand
	pre status = <OnVoting> and
		cand in set dom votes; 
 
 -- Add vote do candidate indicated in current choice
	-- R1: machine is on <OnVoting> status
	-- R2: candidate "choice" must be present in votes
	-- R3: at the end, candidate "choice" must have one more vote
	public confirmChoice: () ==> ()
		confirmChoice() == atomic(
			status := <Ready>;
			votes := votes ++ {choice |-> votes(choice)+1};
			choice := "";
			)
 	pre status = <OnVoting> and
 		choice in set dom votes
 	post choice = "" 
 		and dom votes = dom votes~;
 	-- not suported
	-- post votes = votes~ ++ { candidate |-> votes(candidate)~ + 1 };
 		
 		
	-- Change to "white" vote
	-- R1: machine is on <OnVoting> status
	public cleanSelection: () ==> ()
		cleanSelection() ==
			choice := ""
 	pre status = <OnVoting>;
 	
 	-- End election
 	---------- TODO: finalizar processo - termina a cena toda
 	---------- TODO: -> os dados estao no cartao de memoria <- precisa do cartao de acesso
 	-- R1: machine is on <Ready> status
	public endVoting: () ==> ()
		endVoting() == (
			status := <End>;
			vcardSet := false;
		)
	pre status = <Ready>;
	

end VotingMachine