class VotingMachine

types
	public Status = <Off> | <Ready> | <OnVoting> | <End>;
	public MemCard = map Election`Candidate to nat;

instance variables
	public status : Status := <Off>; 
	public vcard : ElectoralOfficial`Card := mk_token(1);
	public vcardSet : bool := false;
	public choice : Election`Candidate := "blank";
	public votes: MemCard := { "blank" |-> 0};

	------- TODO: o cartao de memoria nao muda
	-- when machine is working it has a vcard set
	inv status = <Ready> or status = <OnVoting> => vcardSet;
	inv {choice} subset dom votes;
	
operations
 	-- Election class constructor
	-- returns created object 
 	public VotingMachine: () ==> VotingMachine
 		VotingMachine() == (
 			return self;
 			);
 	
 	-- Initialize memory and validation cards
 	-- R1: before operation, status must be <Off>
 	-- card must not been entered yet
 	public setCards: ElectoralOfficial`Card ==> ()
 		setCards(vcard1) == (
 			vcard := vcard1;
 			vcardSet := true;
 	)
 	pre status = <Off> and not vcardSet
 	post status = <Off> and vcardSet;
 	
 	-- Turn on the machine
 	public turnOn: ElectoralOfficial`Card ==> ()
 		turnOn(vcard1) == (
 			status := <Ready>
 	)
 	pre vcard1 = vcard
 		and status = <Off>
 	post status = <Ready>;
 	
 	-- Candidates initialization
	-- R1: all candidates in argument "candidates" must have 0 votes
	public setCandidates: map Election`Candidate to nat ==> ()
		setCandidates(candidates) ==
			votes := votes ++ candidates --votes has already blank option
	pre card dom votes = 1 and
		-- all candidates have 0 votes
		forall vote in set rng votes & vote = 0 and
		-- machine is still off
		status = <Off>
		-- votes has so many candidates as candidates plus the blank candidate
	post card dom votes = card dom candidates + 1 and
		-- all candidates have 0 votes
		forall vote in set rng votes & vote = 0;
 	
 	-- Machine ready to receive vote
 	-- R1: before operation, status must be <Ready> 
	public validateCard: ElectoralOfficial`Card ==> ()
		validateCard(vcard1) == atomic (
			status := <OnVoting>;
			choice := "blank"
			)
	pre status = <Ready> and
		vcard1 = vcard
	post status = <OnVoting>;
		
	-- Select candidate
	-- R1: machine is on <OnVoting> status
	-- R2: argument "cand" is a valid candidate (is on memory card)
	public chooseCandidate: Election`Candidate ==> ()
		chooseCandidate(cand) ==
			choice := cand
	pre status = <OnVoting> and
		cand in set dom votes; 
 
 	-- "Submit" vote
	-- R1: machine is on <OnVoting> status
	public confirmChoice: () ==> ()
		confirmChoice() == (
			status := <Ready>;
			addVote()
			)
 	pre status = <OnVoting> and
 		choice in set dom votes
 	post choice = "blank";

	-- Add vote do candidate indicated in current choice
	-- R1: candidate "choice" must be present in votes
	-- R2: at the end, candidate "choice" must have one more vote
	private addVote: () ==> ()
		addVote() == (
			votes := votes ++ {choice |-> votes(choice)+1};
			choice := "blank";
		)
	pre choice in set dom votes
	post dom votes = dom votes~;
	-- not suported
	-- post votes(candidate) = votes(candidate)~ + 1;
	
	
	-- Change to "white" vote
	-- R1: machine is on <OnVoting> status
	public cleanSelection: () ==> ()
		cleanSelection() ==
			choice := "blank"
 	pre status = <OnVoting>;
 	
 	-- End election
 	---------- TODO: finalizar processo - termina a cena toda
 	---------- TODO: -> os dados estao no cartao de memoria <- precisa do cartao de acesso
 	-- R1: machine is on <Ready> status
	public endVoting: () ==> ()
		endVoting() == (
			status := <End>;
			vcardSet := false;
		)
	pre status = <Ready>;

end VotingMachine