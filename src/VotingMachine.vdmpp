class VotingMachine

types
	public Status = <Off> | <Ready> | <OnVoting> | <End>;
	public MemCard = map Election`Candidate to nat;

instance variables
	public status : Status := <Off>; 
	public vcard : ElectoralOfficial`Card := mk_token(1);
	public vcardSet : bool := false;
	public choice : Election`Candidate := "blank";
	public votes: MemCard := { "blank" |-> 0};

	------- TODO: o cartao de memoria nao muda
	-- when machine is working it has a vcard set
	inv status = <Ready> or status = <OnVoting> => vcardSet;
	inv {choice} subset dom votes;
	
operations
 	-- Election class constructor
	-- returns created object 
 	public VotingMachine: () ==> VotingMachine
 		VotingMachine() ==
 			return self;
 	
 	-- Initialize memory and validation cards
 	-- R1: before operation, status must be <Off>
 	-- card must not been entered yet
 	public setCards: ElectoralOfficial`Card ==> ()
 		setCards(vcard1) == (
 			vcard := vcard1;
 			vcardSet := true;
 			status := <Ready>
 	)
 	pre status = <Off>;
 	
 	
 	-- Candidates initialization
	-- R1: all candidates in argument "candidates" must have 0 votes
	public setCandidates: map Election`Candidate to nat ==> ()
		setCandidates(candidates) ==
			votes := votes ++ candidates
		-- votes has already blank option
	pre card dom votes = 1 and
		-- all candidates have 0 votes
		forall vote in set rng votes & vote = 0 and
		-- machine is still off
		status = <Off>
		-- votes has so many candidates as candidates plus the blank candidate
	post card dom votes = card dom candidates + 1 and
		-- all candidates have 0 votes
		forall vote in set rng votes & vote = 0;
 	
 	-- Machine ready to receive vote
 	-- R1: before operation, status must be <Ready> 
 	--------- TODO: recebe-se um cartao que a pessoa recebeu e ve-se se ï¿½ valido ou nao
	public validateCard: ElectoralOfficial`Card ==> ()
		validateCard(vcard1) == atomic (
			status := <OnVoting>;
			choice := "blank"
			)
	pre status = <Ready> and
		vcard1 = vcard
	post status = <OnVoting>;
		
	
	-- Select candidate
	-- R1: machine is on <OnVoting> status
	-- R2: argument "cand" is a valid candidate (is on memory card)
	public chooseCandidate: Election`Candidate ==> ()
		chooseCandidate(cand) ==
			choice := cand
	pre status = <OnVoting> and
		cand in set dom votes; 
 
 	-- "Submit" vote
 	---------- TODO: candidato vazio again
	-- R1: machine is on <OnVoting> status
	public confirmChoice: () ==> ()
		confirmChoice() == (
			status := <Ready>;
			addVote(choice)
			)
 	pre status = <OnVoting> and
 		choice in set dom votes
 	post choice = "blank";


	-- Add vote do candidate indicated in argument "candidate"
	-- R1: "candidate" must be present in votes
	-- R2: at the end, "candidate" must have one more vote
	------ TODO: isto nao deve estar bem
	private addVote: Election`Candidate ==> ()
		addVote(candidate) == (
			votes := votes ++ {candidate |-> votes(candidate)+1};
			choice := "blank";
		)
	pre candidate in set dom votes
	post dom votes = dom votes~;
	-- not suported
	-- post votes(candidate) = votes(candidate)~ + 1;
	
	
	-- Change to "white" vote
	-- R1: machine is on <OnVoting> status
	public cleanSelection: () ==> ()
		cleanSelection() ==
			choice := "blank"
 	pre status = <OnVoting>;
 	
 	-- Give up on voting
	-- R1: machine is on <OnVoting> status
 	public cancelVote: () ==> ()
 		cancelVote() == (
 			choice := "blank";
 			status := <Ready>
 			)
 	pre status = <OnVoting>;
 	
 	-- End election
 	---------- TODO: finalizar processo - termina a cena toda
 	---------- TODO: -> os dados estao no cartao de memoria <- precisa do cartao de acesso
 	-- R1: machine is on <Ready> status
	public endVoting: () ==> ()
		endVoting() == (
			status := <End>;
			vcardSet := false;
		)
	pre status = <Ready>;

	public isValidCard: ElectoralOfficial`Card ==> bool
		isValidCard(c) == (
			return c = vcard;
		)
	pre vcardSet
	post vcard = vcard~;

end VotingMachine