class TestElection1 is subclass of MyTestCase

operations

 	/***** USE CASE SCENARIOS ******/
	
	-- Normal scenario for configuring the election,
	-- as described in section X of the report, covering requirement Y.
	public configureElectionScn: seq of Election`Register * seq of ElectoralOfficial * set of Election`Candidate ==> Election
	configureElectionScn(register, officials,candidates) == (
			dcl election : Election := new Election();
			election.setRegister(register);
			election.setOfficials(officials);
			election.setCandidates(candidates);
			
			--TODO - if you wish check if all person is different
			--for all x in election.officials do for all y in x.machine do y.
			return election;
	)
	post RESULT.electoralRegisters = register 
	     and RESULT.officials = officials;
	    -- and forall off in set elems RESULT.officials & 

	-- Normal scenario for configuring the ElectoralOfficials,
	-- as described in section X of the report, covering requirement Y.
	public configureOfficialsScn: Election ==> ()
	configureOfficialsScn(election) == (
			election.initCodes(); 
			election.turnOnMachines();
	)
	pre forall off in set elems election.officials & (off.machine.status = <Off> and
					not off.vcardSet and
					not off.machine.vcardSet)
	post forall off in set elems election.officials & (off.vcardSet	
	   			and off.machine.vcardSet
	   			and off.vcard = off.machine.vcard
	     		and off.machine.status = <Ready>);
	     		
	-- Normal scenario for validating and autorizing a voter,
	-- as described in section X of the report, covering requirement Y.
	public validateVoterScn: ElectoralOfficial * Election`Person ==> () 
	validateVoterScn(official, person) == (
		dcl vcard: ElectoralOfficial`Card := official.validatePerson(person);
		assertEqual(vcard, official.vcard);
		official.machine.validateCard(vcard); 
		assertEqual(vcard, official.machine.vcard);
	)
	pre person in set dom official.register and
				official.register(person) = false and
				official.machine.status = <Ready> 
	post official.register(person) = true and
				official.machine.status = <OnVoting> and
				official.machine.choice = "";
				
	-- Normal scenario for choosing a candidate and save the vote,
	-- as described in section X of the report, covering requirement Y.
	public voteScn: ElectoralOfficial * Election`Candidate ==> () 
	voteScn(official, candidate) == (
		official.machine.chooseCandidate(candidate);
		official.machine.confirmChoice();
	)
	pre official.machine.status = <OnVoting> and
		candidate in set dom official.machine.votes
	post official.machine.status = <Ready>;
		-- not suported
		-- official.machine.votes = official.machine.votes~ + { candidate |-> official.machine.votes(candidate)+1}

	-- Exceptional voting scenario in which the voter changes candidate option before saving
	-- as described in section X of the report, covering requirement Y.
	public changeVoteScn: ElectoralOfficial * Election`Candidate * Election`Candidate ==> () 
	changeVoteScn(official, candidate1, candidate2) == (
		official.machine.chooseCandidate(candidate1);
		official.machine.cleanSelection();
		official.machine.chooseCandidate(candidate2);
		official.machine.confirmChoice();
	)
	pre official.machine.status = <OnVoting> and
		candidate1 in set dom official.machine.votes and
		candidate2 in set dom official.machine.votes
	post official.machine.status = <Ready>;
	-- not suported
		-- official.machine.votes = official.machine.votes~ + { candidate2 |-> official.machine.votes(candidate2)+1}
	
	
	-- Exceptional voting scenario in which the voter votes in blank
	-- as described in section X of the report, covering requirement Y.
	public blankVoteScn: ElectoralOfficial ==> () 
	blankVoteScn(official) == (
		official.machine.confirmChoice();
	)
	pre official.machine.status = <OnVoting>
	post official.machine.status = <Ready>;
	-- not suported
		-- official.machine.votes = official.machine.votes~ + { "blank" |-> official.machine.votes("blank")+1}
	
	
	/***** TEST CASES WITH VALID INPUTS ******/
	
	-- Entry point that runs all tests with valid inputs
  public testAll: () ==> ()
  	testAll() == (
  		testConf();
  		testVoteAndSave();
  );
	
	-- Test elections' configuration
	-- use case 1 and 2
	-- configure election with 3 ElectoralOfficials, 5 people and 4 candidates
	public testConf: () ==> () 
		testConf() == (
			dcl off : ElectoralOfficial := new ElectoralOfficial();
			dcl off1 : ElectoralOfficial := new ElectoralOfficial();
			dcl off2 : ElectoralOfficial := new ElectoralOfficial();
			dcl person1 : Election`Person := mk_token(1);
			dcl person2 : Election`Person := mk_token(2);
			dcl person3 : Election`Person := mk_token(3);
			dcl person4 : Election`Person := mk_token(4);
			dcl person5 : Election`Person := mk_token(5);
			dcl elc : Election := configureElectionScn([{person1 |-> false, person2 |-> false}, {person3 |-> false, person4 |-> false}, {person5 |-> false}], [off, off1, off2],{"a","b","c","d"});
			configureOfficialsScn(elc);
	
			for all official in set elems elc.officials do
				assertEqual(dom official.machine.votes, {"a","b","blank","c","d"});
			);
	
	-- use cases 3 & 4 & 5
	public testVoteAndSave: () ==> () 
		testVoteAndSave() == (
			dcl off : ElectoralOfficial := new ElectoralOfficial();
			dcl off1 : ElectoralOfficial := new ElectoralOfficial();
			dcl off2 : ElectoralOfficial := new ElectoralOfficial();
			dcl person1 : Election`Person := mk_token(1);
			dcl person2 : Election`Person := mk_token(2);
			dcl person3 : Election`Person := mk_token(3);
			dcl person4 : Election`Person := mk_token(4);
			dcl person5 : Election`Person := mk_token(5);
			dcl elc : Election := configureElectionScn([{person1 |-> false, person2 |-> false}, {person3 |-> false, person4 |-> false}, {person5 |-> false}], [off, off1, off2],{"a","b","c","d"});
			dcl votes : map Election`Candidate to nat := { |-> };
			configureOfficialsScn(elc);
			
			
			validateVoterScn(off, person1); 
			voteScn(off, "a");
			elc.endElection();
			votes := elc.countVotes();
			assertEqual (off.machine.votes("a"), 1);
			IO`print(votes);
			);
			
end TestElection1